[](../Screenshot%202025-11-05%20154522.png)
This repository contains an NES emulator I worked on over the course of several months from 2024-2025 during my Freshman year (note that this was not a school project). The only other emulator I have written before was for a fake computer called the Chip-8, the "Hello World!" of emulator development. I was interested in emulating a real system, one which would be larger and harder to emulate, so i picked the NES. I enjoyed this project, both as a challenge, and for teaching me how to build, debug, and develop multi-thousand line projects.

I had some misconceptions on how computers worked at a low-level at this point which is reflected in the design, like assuming CPU instructions each took 1 cycle to execute, and then after learning they varied, assuming each instruction took a constant number of cycles (also incorrect, because instructions like the conditional jumps depended on the jump being taken or if the jump was across the page boundry). Regardless, I was able to rework and refactor the code into being able to pass the nestest.nes test ROM (excluding illegal instructions). This taught me a lot of things about low-level CPU function, as well as how it functioned with other components in the system like the PPU.

The PPU was far harder than the CPU to implement. The documentation was more sparse and scattered, and while it did have a fixed set of things it did, dealing with the exact timings, CPU interactions, quirks with sprites, flags, and mappers made it take the most time. Even now, while I have emulated it at cycle-level granularity, there are a few bugs causing instability. 

Beyond learning how the NES worked, this project also made me a better developer. Firstly, working with a large project teaches what to do and what not to do. One good choice I made was seperating and modularizing memory access and databuses, which when I learned about some addresses actually being registers for different components, made it easier to implement. One bad choice is not testing sooner. I first made this mistake developing the CPU, which made development take far longer. Then I made this mistake when developing the PPU. I eventually fixed these mistakes by creating specialized debuggers (the in-built GUI debugger was good to find what line I erred on, but finding out that I erred and how I erred at a higher level required my own tools) and testers, which enormously improved development speed. I am personally fond of the PPU debugger I made, which inludes savestates and pixel-by-pixel iteration. This testing process also broadened my idea of testing, which isn't just limited to unit-testing but can involve less concrete "tests" such as playing and getting a feel as to what is wrong.

I still have a lot to learn regarding software development. I hope to be more organized in my next major project and go beyond commenting out code to run tests, but I feel a lot more confident with C++ after accomplishing this.
